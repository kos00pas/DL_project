This is the third of three papers describing zap a satisﬁability engine that substantially generalizes existing tools while retaining the performance characteristics of modern high performance solvers The fundamental idea underlying zap is that many problems passed to such engines contain rich internal structure that is obscured by the Boolean representation used our goal has been to deﬁne a representation in which this structure is apparent and can be exploited to improve computational performance The ﬁrst paper surveyed existing work that  exploited problem structure to improve the performance of satisﬁability engines and the second paper showed that this structure could be understood in terms of groups of permutations acting on individual clauses in any particular Boolean theory We conclude the series by discussing the techniques needed to implement our ideas and by reporting on their performance on a variety of problem instances 1 Introduction All rights reserved Dixon Ginsberg Hofer Luks  Parkes We showed that an implementation based on these ideas could be expected to combine the attractive computational properties of a variety of recent ideas including eﬃcient imple mentations of unit propagation  and extensions of the Boolean lan guage to include cardinality or pseudoBoolean constraints  parity problems  or a limited form of quantiﬁcation known as qprop  In this paper we discuss the implementation of a prover based on these ideas and describe its performance on pigeonhole parity and clique coloring problems These classes of problems are known to be exponentially diﬃcult for conventional Boolean satisﬁability engines and their formalization also highlights the groupbased nature of the reasoning involved From a technical point of view this is the most diﬃcult of the three zap papers we need to draw on the algorithms and theoretical constructions from zap2 and on results from com putational group theory  regarding their implementation Our overall plan for describing the implementation is as follows 1 Section 2 is a review of material from zap2 We begin in Section 21 by presenting both the Boolean satisﬁability algorithms that we hope to generalize and the basic algebraic ideas underlying zap Section 22 describes the grouptheoretic computations required by the zap implementation 2 Section 3 gives a brief  and necessarily incomplete  introduction to some of the ideas in computational group theory that we use 3 Sections 4 and 5 describe the implementations of the computations discussed in Sec tion 2 For each basic construction we describe the algorithm used and give an example of the computation in action If there is an existing implementation of some thing in the public domain system gap  we only provide a pointer to that implementation for concepts that we needed to implement from scratch additional detail is provided 4 Section 6 extends the basic algorithms of Section 5 to deal with unit propagation where we want to compute not a single unit clause instance but a list of all of the unit consequences of an augmented clause 5 Section 7 discusses the implementation of Zhang and Stickels  watched literal idea in our setting 6 Section 8 describes a technique that can be used to select among the possible resolvents of two augmented clauses This is functionality with no analog in a conventional prover where there is only a single ground reason for the truth or falsity of any given variable If the reasons are augmented clauses there may be a variety of ways in which ground instances of those clauses can be combined 7 After describing the algorithms we present experimental results regarding perfor mance in Sections 9 and 10 Section 9 reports on the performance of zaps individual algorithmic components while Section 10 contrasts zaps overall performance to that of its cnfbased predecessors1 Since our focus in this paper is on the algorithms 1