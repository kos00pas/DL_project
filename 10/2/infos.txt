Introduction: This is the third of three papers describing zap a satisﬁability engine that substantially generalizes existing tools while retaining the performance characteristics of modern high performance solvers The fundamental idea underlying zap is that many problems passed to such engines contain rich internal structure that is obscured by the Boolean representation used our goal has been to deﬁne a representation in which this structure is apparent and can be exploited to improve computational performance The ﬁrst paper surveyed existing work that  exploited problem structure to improve the performance of satisﬁability engines and the second paper showed that this structure could be understood in terms of groups of permutations acting on individual clauses in any particular Boolean theory We conclude the series by discussing the techniques needed to implement our ideas and by reporting on their performance on a variety of problem instances 1 Introduction All rights reserved Dixon Ginsberg Hofer Luks  Parkes We showed that an implementation based on these ideas could be expected to combine the attractive computational properties of a variety of recent ideas including eﬃcient imple mentations of unit propagation  and extensions of the Boolean lan guage to include cardinality or pseudoBoolean constraints  parity problems  or a limited form of quantiﬁcation known as qprop  In this paper we discuss the implementation of a prover based on these ideas and describe its performance on pigeonhole parity and clique coloring problems These classes of problems are known to be exponentially diﬃcult for conventional Boolean satisﬁability engines and their formalization also highlights the groupbased nature of the reasoning involved From a technical point of view this is the most diﬃcult of the three zap papers we need to draw on the algorithms and theoretical constructions from zap2 and on results from com putational group theory  regarding their implementation Our overall plan for describing the implementation is as follows 1 Section 2 is a review of material from zap2 We begin in Section 21 by presenting both the Boolean satisﬁability algorithms that we hope to generalize and the basic algebraic ideas underlying zap Section 22 describes the grouptheoretic computations required by the zap implementation 2 Section 3 gives a brief  and necessarily incomplete  introduction to some of the ideas in computational group theory that we use 3 Sections 4 and 5 describe the implementations of the computations discussed in Sec tion 2 For each basic construction we describe the algorithm used and give an example of the computation in action If there is an existing implementation of some thing in the public domain system gap  we only provide a pointer to that implementation for concepts that we needed to implement from scratch additional detail is provided 4 Section 6 extends the basic algorithms of Section 5 to deal with unit propagation where we want to compute not a single unit clause instance but a list of all of the unit consequences of an augmented clause 5 Section 7 discusses the implementation of Zhang and Stickels  watched literal idea in our setting 6 Section 8 describes a technique that can be used to select among the possible resolvents of two augmented clauses This is functionality with no analog in a conventional prover where there is only a single ground reason for the truth or falsity of any given variable If the reasons are augmented clauses there may be a variety of ways in which ground instances of those clauses can be combined 7 After describing the algorithms we present experimental results regarding perfor mance in Sections 9 and 10 Section 9 reports on the performance of zaps individual algorithmic components while Section 10 contrasts zaps overall performance to that of its cnfbased predecessors1 Since our focus in this paper is on the algorithms 1 A description of zaps input language is contained in Appendix B 442 ZAP 3 Implementation needed by zap we report performance only for relatively theoretical examples that clearly involve groupbased reasoning Performance on a wider range of problem classes will be reported elsewhere 8 Concluding remarks appear in Section 11 Except for Section 3 proofs are generally deferred to Appendix A in the interests of main taining the continuity of our exposition Given the importance of computational group theory to the ideas that we will be presenting we strongly suggest that the reader work through the proofs in Section 3 of the paper This is a long and complex paper we make no apologies Zap is an attempt to synthesize two very diﬀerent ﬁelds each complex in its own right computational group theory and implementations of Boolean satisﬁability engines Computational group theory in addition to its inherent complexity is likely to be foreign to an AI audience Work on complete algorithms for Boolean satisﬁability has also become increasingly sophisticated over the past decade or so with the introduction of substantial and nonintuitive modiﬁcations to the original dpll algorithm such as relevancebounded learning  and watched literals  As we bring these two ﬁelds together we will see that a wide range of techniques from computational group theory is relevant to the problems of interest to us our goal is also not simply to translate dpll to the new setting but to show that all of the recent work on Boolean satisﬁability can be moved across In at least one case Lemma 526 we also need to extend existing computational group theory results And ﬁnally there are new satisﬁability techniques and possibilities that arise only because of the synthesis that we are proposing  and we will describe some of those as well This paper is not intended to be selfcontained We assume throughout that the reader is familiar with the material that we presented in zap2 some of the results from that paper are repeated here for convenience but the accompanying text is not intended to stand alone Finally  and in spite of the disclaimers of the previous two paragraphs  this paper is not intended to be complete Our goal is to present a practical minimum of what is required to implement an eﬀective groupbased reasoning system The results that we have obtained both theoretical as described in zap2 and practical as described here excite us But we are just as excited by the number of issues that we have not yet explored Our primary goal is to present the foundation needed if other interested researchers are to explore these ideas with us 2 ZAP Fundamentals and Basic Structure
Problem and Solution: No problem or solution section found.
Conclusion: liquecoloring problems should not be thought of as unsatisﬁable instances of graphcoloring problems generally A particular instance of this problem class does not describe a speciﬁc graph that needs to be colored it says only that the graph contains an mclique and needs to be colored in m 1 colors An axiomatization of this problem is as follows We use eij to describe the graph cij to describe the coloring of the graph and qij to describe the embedding of the clique into the graph The graph has m nodes the clique is of size n  1 and we are trying to use just two colors The ﬁrst group is the symmetry over colors alone the second that over the elements of the clique and the third the symmetry over nodes The axiomatization is identical to that presented earlier Note that although there is a common symmetry in this problem the axiomatization obscures that in some sense since we have only included the relevant symmetry or symmetries in any particular axiom Times to solution for zap and zChaff are shown in  As might be expected zChaff is scaling exponentially zap appears to be scaling as n85 In order to allow the data to be presented along a single axis these problem instances were selected so that the clique size was one smaller than the graph size  shows the number of nodes expanded by the two systems Once again the number of nodes expanded by zChaff is growing exponentially with problem size while the number expanded by zap is growing polynomially g  14 2 where c is the size of the clique and g the size of the graph There were a handful of outliers most notably the c  11 g  13 instance which expanded a larger number of nodes The other exceptions all expanded fewer nodes With regard to total CPU time  the time appears to be scaling as 389 Once again c  11 g  13 is an outlier but polynomial performance is observed generally To the best of our knowledge zap is the ﬁrst system to exhibit polynomial performance on this problem class as we have remarked most other approaches have been proven to scale exponentially 104 Related Work Finally we compare our experimental results to those obtained using other systems that attempt to exploit problem structure to improve the performance of satisﬁability solvers This section provides a highlevel summary of experimental results for a number of these 505 Dixon Ginsberg Hofer Luks  Parkes 1 10 100 1000 10000 100000 1e06 1e07 4 6 8 10 12 14 16 18 nodes graph size  zap zchaff  Nodes expanded in the clique problems eﬀorts and compares these results with zap on the benchmark problems described in the previous sections Recall that our benchmark problems are all highly structured but each has a very dif ferent type of structure Theoretically these problems all allow polynomialtime solutions but they are provably hard for conventional solvers A solver that solves all of these prob lems eﬃciently has the ability to exploit a range of diﬀerent types of problem structure and automates a strong proof system Of course to be interesting a solver must also be a practical general purpose solver For example Tseitin problems can be solved in polynomial time by a form of Gaussian elimination  and pigeonhole problems can be solved in polynomial time by a linear programming method such as the simplex method However neither of these solutions constitutes a practical general purpose solver We ran a number of solvers on the benchmark problems obtaining the following results pigeonhole Tseitin clique coloring zap P nlog n P zChaff E E E pbchaff P E E eqsatz E E E march eq E E  E resolution E E  E cuttingplanes or integer programming P  E 506 ZAP 3 Implementation 4 6 8 10 12 10 10 100 1000 nodes zap 0075 xy252 clique size graph size  Nodes expanded in the clique problems Rather than presenting numerous graphs we summarize our results above simply re porting the overall scaling of each solver on each problem class Polynomialtime scaling is indicated with a P and exponentialtime scaling with an E Scaling is shown for the three problem classes we have discussed with two separate encodings considered for the Tseitin problems The ﬁrst encoding is the Booleanization of the encoding of Section 102 the second involves the introduction of new variables to reduce clause length and is described below If the performance is improved by this introduction the new scaling is given par enthetically The ﬁnal two rows give known proof complexity results for the resolution and cuttingplanes proof systems and thus provide lower bounds on the corresponding rows above them Reducing performance results to exponential or polynomial scaling omits valuable in formation Clearly the diﬀerence between n100 and n2 scaling is something we care about although both are polynomial The details of speciﬁc scaling factors will be included in the discussion that follows our goal in the table is merely to summarize the strength of each solvers underlying proof system Details of the solvers appearing in the table are as follows  pbchaff is a pseudoBoolean version of the dpll algorithm